---
title: "1.3 Propensity Score Matching"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

## Load Packages

```{r}
library(dplyr)        # Pak for data management
library(MatchIt)      # Pak for PSM
library(lmtest)       # Pak for LRT
# library(sandwich)     # ??? why we need this
library(dgof)         # k.s test
library(spatstat)     # for weighted cdf function
```

## Load Dataset

```{r}
# CLSA comprehensive cohort: N=7678 
load(file='../1_data/private/CLSA_mncom.RData')

# CLSA comprehensive cohort: N=7230
load(file='../1_data/private/CLSA_com50.RData')
```

# ===================== Part I. Propensity Score Matching ==================

## 1. Model Building

#### 1.1 Match_01 small model
```{r}
# Simple model for PSM, using age, sex, urbanicity, edu (numeric)
match_01 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                      URBAN_RURAL_COVID +
                      SER_EDU_COV,
    data=CLSA_mncom[is.na(CLSA_mncom$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_mncom$SER_EDU_COV)==F ,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)
summary(match_01)

#plotting the balance between DBS and VBS
plot(match_01, type = "jitter", interactive = FALSE)
plot(summary(match_01), abs = FALSE) # looks good
```

#### 1.2 Match_02: Adding more demographic variables

```{r}
# Adding all the available demo variables, 
match_02 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                      as.factor(URBAN_RURAL_COVID) +
                      SER_EDU_COV + SER_ETHN_WH_COV +
                      SER_FAMPH_COV,
    data=CLSA_mncom[is.na(CLSA_mncom$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_mncom$SER_EDU_COV)==F &
                    is.na(CLSA_mncom$SER_FAMPH_COV)==F &
                    is.na(CLSA_mncom$SER_ETHN_WH_COV)==F ,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)
summary(match_02)

#plotting the balance between DBS and VBS
plot(match_02, type = "jitter", interactive = FALSE)
plot(summary(match_02), abs = FALSE) # looks good
```

#### 1.3 Matched Pairs 3: added Health vars (physical, mental, mobility)

```{r}
match_03 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                      as.factor(URBAN_RURAL_COVID) +
                      SER_EDU_COV + SER_ETHN_WH_COV + SER_FAMPH_COV +
                      min_health + maj_health_bin +
                      GAD_NBRMIS_COVX + DEP_CESD10_COVX +
                      FUL_SIT1H_COVX,
    data=CLSA_mncom[is.na(CLSA_mncom$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_mncom$SER_EDU_COV)==F &
                    is.na(CLSA_mncom$SER_FAMPH_COV)==F &
                    is.na(CLSA_mncom$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_mncom$min_health)==F &
                    is.na(CLSA_mncom$maj_health)==F &
                    is.na(CLSA_mncom$DEP_CESD10_COVX)==F &
                    is.na(CLSA_mncom$FUL_SIT1H_COVX)==F,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)
summary(match_03)

#plotting the balance between DBS and VBS
plot(match_03, type = "jitter", interactive = FALSE)
plot(summary(match_03), abs = FALSE) # looks good
```

#### 1.4  Matched Pairs 4: all variables, full model

We are using com50 data (only keep those live within 50-km to DCS), adding time, pcr+ tests, vaccination, hospitalization and provinces groups into the model:

```{r}
match_04 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                      as.factor(URBAN_RURAL_COVID) +
                      SER_EDU_COV + SER_ETHN_WH_COV + SER_FAMPH_COV +
                      min_health + maj_health_bin +
                      GAD_NBRMIS_COVX + DEP_CESD10_COVX +
                      FUL_SIT1H_COVX + dist_min +
                      SER_RSLT_SUM_bin15 + time_vac15 +
                      PROV_5 + outbreak,
    data=CLSA_com50[is.na(CLSA_com50$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_com50$SER_EDU_COV)==F &
                    is.na(CLSA_com50$SER_FAMPH_COV)==F &
                    is.na(CLSA_com50$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_com50$min_health)==F &
                    is.na(CLSA_com50$maj_health)==F &
                    is.na(CLSA_com50$DEP_CESD10_COVX)==F &
                    is.na(CLSA_com50$FUL_SIT1H_COVX)==F &
                    is.na(CLSA_com50$outbreak)==F,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)
summary(match_04)

#plotting the balance between DBS and VBS
plot(match_04, type = "jitter", interactive = FALSE)
plot(summary(match_04), abs = FALSE) # looks good
```

1.4.a Matched Pairs 4.a: Add all we have, but subclass

```{r}
match_04.a <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
            as.factor(URBAN_RURAL_COVID) +
            as.factor(SER_EDU_COV) + SER_ETHN_WH_COV + SER_FAMPH_COV +
            min_health + maj_health_bin +
            GAD_NBRMIS_COVX + DEP_CESD10_COVX +
            FUL_SIT1H_COVX + dist_min+
            SER_RSLT_SUM_bin15 + time_vac15 +
            PROV_5 + outbreak, 
            data=CLSA_com50[is.na(CLSA_com50$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_com50$SER_EDU_COV)==F &
                    is.na(CLSA_com50$SER_FAMPH_COV)==F &
                    is.na(CLSA_com50$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_com50$min_health)==F &
                    is.na(CLSA_com50$maj_health)==F &
                    is.na(CLSA_com50$DEP_CESD10_COVX)==F &
                    is.na(CLSA_com50$FUL_SIT1H_COVX)==F &
                    is.na(CLSA_com50$outbreak)==F,],
             method = "subclass",distance ="glm", 
             subclass=8, estimand = 'ATE',
             ratio = 1, replace = FALSE)
summary(match_04.a)

plot(summary(match_04.a), abs = FALSE) # looks better than "nearest"
```

#### 1.5 Model 06, Best-fit model with minimal AIC 
This model will be what we used for PSM modeling, its purpose is to calculate propensity score.

```{r}
#model.06, multivariate regression model
lm06 <- glm(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
            as.factor(URBAN_RURAL_COVID) +
            SER_ETHN_WH_COV  +
            as.factor(SER_EDU_COV) +
            DEP_CESD10_COVX +
            dist_min +
            time_vac15 +
            PROV_5 + outbreak, 
            data=CLSA_com50[is.na(CLSA_com50$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_com50$SER_EDU_COV)==F &
                    is.na(CLSA_com50$SER_FAMPH_COV)==F &
                    is.na(CLSA_com50$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_com50$min_health)==F &
                    is.na(CLSA_com50$maj_health)==F &
                    is.na(CLSA_com50$DEP_CESD10_COVX)==F &
                    is.na(CLSA_com50$FUL_SIT1H_COVX)==F &
                    is.na(CLSA_com50$outbreak)==F,],
            family = binomial(link='logit'))
summary(lm06)
```

Looking for Best-Fit Model using AIC algorithm

```{r}
library(MASS)     # For automatic step-wise model selection

# Create Complete Cases 
CLSA_com50s<-CLSA_com50 %>%
  dplyr::select(SER_ADM_COV, AGE_NMBR_COVID , SEX_CLSA ,
            URBAN_RURAL_COVID ,
            SER_EDU_COV, SER_ETHN_WH_COV , SER_FAMPH_COV ,
            min_health , maj_health_bin ,
            GAD_NBRMIS_COVX , DEP_CESD10_COVX ,
            FUL_SIT1H_COVX , dist_min,
            SER_RSLT_SUM_bin15 , time_vac15 ,
            PROV_5 , outbreak)
CLSA_com50s<-na.omit(CLSA_com50s)
CLSA_com50s$URBAN_RURAL_COVID<-as.factor(CLSA_com50s$URBAN_RURAL_COVID)
CLSA_com50s$SER_EDU_COV<-as.factor(CLSA_com50s$SER_EDU_COV)
  

lmAIC <- glm(SER_ADM_COV~., data=CLSA_com50s, family = binomial(link='logit'))
stepAIC(lmAIC, direction = 'backward')

# Same as model 06, we good
```

Matched Paires using Model 06

```{r}
match_06 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
    data=CLSA_com50[is.na(CLSA_com50$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_com50$SER_EDU_COV)==F &
                    is.na(CLSA_com50$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_com50$DEP_CESD10_COVX)==F &
                    is.na(CLSA_com50$outbreak)==F,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)
summary(match_06)

#plotting the balance between DBS and VBS
plot(match_06, type = "jitter", interactive = FALSE)
plot(match_06, type = "hist", interactive = FALSE)
plot(summary(match_06), abs = FALSE) # looks not good

plot(match_06, type = "density", interactive = FALSE,
     which.xs = ~AGE_NMBR_COVID + SEX_CLSA)
```

Any other way to improve the matching? - use different methods: we used subclass instead of nearest. This matching methods matched within subclasses created based on propensity score. Usually they use 6 subclasses but in our case since it's difficult to reach balance, we will use 8.

As we proceed with diff matching methods we realized the sample size in the control group is the reason why we could not reach the balance between DBS & VBS. Since the sample size in DBS (control) is slightly more than that in cases (VBS), few unmatched cases were abandoned given the 1:1 case-control ratio. For options with fewer number of cases (certain % of cases will be abandoned randomly), see sections below.


##### Addtional codes for custom SMD (Standard Mean Diff) figure
```{r}
match_06.a <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
    data=CLSA_com50[is.na(CLSA_com50$URBAN_RURAL_COVID)==F &
                    is.na(CLSA_com50$SER_EDU_COV)==F &
                    is.na(CLSA_com50$SER_ETHN_WH_COV)==F &
                    is.na(CLSA_com50$DEP_CESD10_COVX)==F &
                    is.na(CLSA_com50$outbreak)==F,],
    method = "subclass",distance ="glm", subclass=8,
    estimand = 'ATE',
    ratio = 1, replace = FALSE)
summary(match_06.a, subclass = T)

# Making Plots
plot(match_06.a, type = "hist", interactive = FALSE) # use hist instead of jitter plot, since every entry has been utilized for matching, but with diff weights. In this case hist is a better option to present diff btw matched pairs.

plot(summary(match_06.a), abs = FALSE) # looks good

# Concise version of plot:
sum.match06a<-summary(match_06.a)
tab01<-sum.match06a$sum.all
tab02<-sum.match06a$sum.across

namelist<-c("Overall Difference", "Age", "Sex: Female", "Sex: Male",
            "UB/Rural: Rural", "UB/Rural: Urban Core", "UB/Rural: Urban Fringe",
            "UB/Rural: Urban Out of CMA/CA", "UB/Rural: 2nd Urban Core",
            "UB/Rural: DA Only", "Race: Non-WH", "Race: WH", "Edu: <High School", 
            "Edu: High School", "Edu: Vocational Tr", "Edu: Non-uni cert", 
            "Edu: Bachelor", "Edu: Graduate", "Dep Scale", "Travel Dist",
            "Vax over 15 days: No", "Vax over 15 days: Yes", "Prov Group: NFL & NS",
            "Prov Group: QC","Prov Group: ON","Prov Group: MT & AB","Prov Group: BC",
            "Outbreak Peak: No", "Outbreak Peak: Yes")
rownames(tab01)<-namelist
rownames(tab02)<-namelist

sum.match06a$sum.all<-tab01
sum.match06a$sum.across<-tab02

# Use those two lines for continuous var only
# sum.match06a$sum.all<-tab01[c(1,2,19,20),]
# sum.match06a$sum.across<-tab02[c(1,2,19,20),]

# All vars
png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.2 Match_subclass.png", 
    width=2650, height=2400, res=300)
plot(sum.match06a, abs = F,
     main = "Standardized Mean Difference (SMD) DBS vs VBS")
dev.off()

# Only Continuous Vars
# plot(sum.match06a, abs = F,
#     main = "Standardized Mean Difference (SMD) btw DBS & VBS, 
#             Numeric Var only")
```


Other possible way of matching:
```{r}
# Avoid running matchit() with method='genetic', it tooks forwever to run

# use generalzied boosted model instead, as the replacement of logistic model
library(gbm)
CLSA_com50.c6$SEX_CLSA<-as.factor(CLSA_com50.c6$SEX_CLSA)
gps <- gbm(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
           data=CLSA_com50.c6, distribution = "bernoulli",n.trees = 2000, 
           interaction.depth = 4, train.fraction = 0.8, shrinkage=0.0005)
summary(gps)
```
Note: The "GBM" function is available in weightit() as an option. However we are not sure the paramaters in the function.

#### 1.6 Matching, but with decreased case-control ratio

Match 07, sample 90% cases
```{r}
set.seed(112006)
CLSA_com50.m7<-CLSA_com50[CLSA_com50$SER_ADM_COV==1,] %>%
                          sample_n(., size=round((3457*0.9), digits=0),
                                   replace=FALSE) %>%
                          mutate(., case_chosen=1)

CLSA_com50.m7<-merge(CLSA_com50, 
                     dplyr::select(CLSA_com50.m7, entity_id, case_chosen), 
                     all.x = T, all.y = F, by='entity_id')
CLSA_com50.m7$case_chosen[is.na(CLSA_com50.m7$case_chosen)==T]<-0
CLSA_com50.m7$case_chosen[CLSA_com50.m7$SER_ADM_COV==0]<-1
# Check the sampling
table(CLSA_com50.m7$SER_ADM_COV, CLSA_com50.m7$case_chosen)

match_07 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
    data=CLSA_com50.m7[is.na(CLSA_com50.m7$URBAN_RURAL_COVID)==F &
                      is.na(CLSA_com50.m7$SER_EDU_COV)==F &
                      is.na(CLSA_com50.m7$SER_ETHN_WH_COV)==F &
                      is.na(CLSA_com50.m7$DEP_CESD10_COVX)==F &
                      is.na(CLSA_com50.m7$outbreak)==F &
                      CLSA_com50.m7$case_chosen==1,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)

#plotting the balance between DBS and VBS
plot(match_07, type = "jitter", interactive = FALSE)
plot(summary(match_07), abs = FALSE) # looks better
```

Match 08, sample 80% cases
```{r}
set.seed(112006)
CLSA_com50.m8<-CLSA_com50[CLSA_com50$SER_ADM_COV==1,] %>%
                          sample_n(., size=round((3457*0.8), digits=0),
                                   replace=FALSE) %>%
                          mutate(., case_chosen=1)

CLSA_com50.m8<-merge(CLSA_com50, 
                     dplyr::select(CLSA_com50.m8, entity_id, case_chosen), 
                     all.x = T, all.y = F, by='entity_id')
CLSA_com50.m8$case_chosen[is.na(CLSA_com50.m8$case_chosen)==T]<-0
CLSA_com50.m8$case_chosen[CLSA_com50.m8$SER_ADM_COV==0]<-1
# Check the sampling
table(CLSA_com50.m8$SER_ADM_COV, CLSA_com50.m8$case_chosen)

match_08 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
    data=CLSA_com50.m8[is.na(CLSA_com50.m8$URBAN_RURAL_COVID)==F &
                      is.na(CLSA_com50.m8$SER_EDU_COV)==F &
                      is.na(CLSA_com50.m8$SER_ETHN_WH_COV)==F &
                      is.na(CLSA_com50.m8$DEP_CESD10_COVX)==F &
                      is.na(CLSA_com50.m8$outbreak)==F &
                      CLSA_com50.m8$case_chosen==1,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)

#plotting the balance between DBS and VBS
plot(match_08, type = "jitter", interactive = FALSE)
plot(summary(match_08), abs = FALSE) # looks better
```

Match 09, sample 60% cases - here the balance between DBS & VBS are reached
```{r}
set.seed(112006)
CLSA_com50.m9<-CLSA_com50[CLSA_com50$SER_ADM_COV==1,] %>%
                          sample_n(., size=round((3457*0.6), digits=0),
                                   replace=FALSE) %>%
                          mutate(., case_chosen=1)

CLSA_com50.m9<-merge(CLSA_com50, 
                     dplyr::select(CLSA_com50.m9, entity_id, case_chosen), 
                     all.x = T, all.y = F, by='entity_id')
CLSA_com50.m9$case_chosen[is.na(CLSA_com50.m9$case_chosen)==T]<-0
CLSA_com50.m9$case_chosen[CLSA_com50.m9$SER_ADM_COV==0]<-1
# Check the sampling
table(CLSA_com50.m9$SER_ADM_COV, CLSA_com50.m9$case_chosen)

match_09 <- matchit(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                    URBAN_RURAL_COVID +
                    SER_ETHN_WH_COV  +
                    SER_EDU_COV +
                    DEP_CESD10_COVX +
                    dist_min + time_vac15 +
                    PROV_5 + outbreak, 
    data=CLSA_com50.m9[is.na(CLSA_com50.m9$URBAN_RURAL_COVID)==F &
                      is.na(CLSA_com50.m9$SER_EDU_COV)==F &
                      is.na(CLSA_com50.m9$SER_ETHN_WH_COV)==F &
                      is.na(CLSA_com50.m9$DEP_CESD10_COVX)==F &
                      is.na(CLSA_com50.m9$outbreak)==F &
                      CLSA_com50.m9$case_chosen==1,],
    method = "nearest",distance ="glm",
    ratio = 1, replace = FALSE)

#plotting the balance between DBS and VBS
plot(match_09, type = "jitter", interactive = FALSE)
plot(summary(match_09), abs = FALSE) # looks better
```

# ===================== Part II. Propensity Score Weighting ================== #

## 1. Calculate weights using IPTW, manually calculation

```{r}
# clean dataset for model 6
CLSA_com50.c6<-CLSA_com50 %>%
  dplyr::select(SER_ADM_COV, AGE_NMBR_COVID , SEX_CLSA ,
            URBAN_RURAL_COVID ,
            SER_ETHN_WH_COV  ,
            SER_EDU_COV ,
            DEP_CESD10_COVX ,
            dist_min ,
            time_vac15,
            PROV_5, outbreak,
            SER_NUCLEOCAPSID_COV, SER_SPIKE_COV, SPIKE_ANTIBODY)
CLSA_com50.c6<-na.omit(CLSA_com50.c6)

# We will use model 6
lm06 <- glm(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
            URBAN_RURAL_COVID +
            SER_ETHN_WH_COV  +
            SER_EDU_COV +
            DEP_CESD10_COVX +
            dist_min +
            time_vac15 +
            PROV_5 + outbreak, 
            data=CLSA_com50.c6,
            family = binomial(link='logit'))
summary(lm06)

# Use those two lines for generate propensity score, using glm or gbm
CLSA_com50.c6$psvalue<-predict(lm06, type = 'response')
#CLSA_com50.c6$psvalue<-predict(gps, type = 'response')

CLSA_com50.c6$weight.ATE<-ifelse(CLSA_com50.c6$SER_ADM_COV==1,
                                 1/CLSA_com50.c6$psvalue, 
                                 1/(1-CLSA_com50.c6$psvalue))
CLSA_com50.c6 %>%
  group_by(SER_ADM_COV) %>%
  group_walk(~hist(.$weight.ATE))

# OR of anti-N positive
psw.06.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=CLSA_com50.c6, family = binomial(link = "logit"),
    weights = weight.ATE)
# ummary(psw.06.N)

psw.06.N %>%
  tbl_regression(exponentiate = T)

# OR of anti-S positive
psw.06.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
    data=CLSA_com50.c6, family = binomial(link = "logit"),
    weights = weight.ATE)
psw.06.S %>%
  tbl_regression(exponentiate = T)
```

## Add weights calculated using {weightit} pak - same as manually calculated weights

```{r}
# Load pak
library(WeightIt)
library(cobalt)      # bal.tab() for imbalance tab

w.01 <- weightit(SER_ADM_COV~age10 + SEX_CLSA +
                             urban_rural +
                             SER_ETHN_WH_COV  +
                             SER_EDU_COV +
                             DEP_CESD10_COVX +
                             dist_min_25km +
                             time_vac15 +
                             PROV_5 + avginc10_15d, 
            data=CLSA_com50.c6, estimand = 'ATE', method = 'glm')
summary(w.01)

# Access imbalance

# unweighted data
bal.tab(SER_ADM_COV~AGE_NMBR_COVID + SEX_CLSA +
                             URBAN_RURAL_COVID +
                             SER_ETHN_WH_COV  +
                             SER_EDU_COV +
                             DEP_CESD10_COVX +
                             dist_min +
                             time_vac15 +
                             PROV_5 + outbreak, 
       data=CLSA_com50.c6 , estimand = "ATE", thresholds = c(m = .05))
# OK, but few are not balanced

# weighted data using 'weightit'
bal.01<-bal.tab(w.01, stats = c("m", "ks.statistics"), 
                thresholds = c(m = .05, ks=0.05), 
                un=T, continuous = "std") # looks good
bal.plot(w.01,  which = 'both') # dist of propensity score

CLSA_com50.c6$w.weights<-w.01$weights

# manually weights vs weightit weights:
CLSA_com50.c6<-CLSA_com50.c6 %>%
  mutate(w_compare = w.weights - weight.ATE)

summary(CLSA_com50.c6$w_compare)

plot(bal.01)
plot(summary(w.01))    
```

#### The hist: dist of weights across two groups, DSB vs VBS
```{r}
# create transparent color:
c1 <- rgb(173,216,230, max = 255, alpha = 85, names = "lt.blue")
c2 <- rgb(255,192,203, max = 255, alpha = 85, names = "lt.pink")

# set breaks with pretty()
A<-CLSA_com50.c6$w.weights[CLSA_com50.c6$SER_ADM_COV==0]
B<-CLSA_com50.c6$w.weights[CLSA_com50.c6$SER_ADM_COV==1]

b <- min(c(A,B))-0.001     # Set the minimum for the breakpoints
e <- max(c(A,B))           # Set the maximum for the breakpoints
ax <- pretty(b:e, n = 30)  # Make a neat vector for the breakpoints

hgA <- hist(A, breaks = ax, plot = FALSE) # Save first histogram data
hgB <- hist(B, breaks = ax, plot = FALSE) # Save 2nd histogram data

plot(hgA, col = c1, ylim = c(0,650),
     main = 'Histogram of Weights by Group',
     xlab = 'IPTW Weights')             
plot(hgB, col = c2, add = TRUE) 
legend("topright", legend = c("DBS", "VBS"),
       lwd = 3, col = c(c1, c2))

# Plot the distribution of weights separately, by applying plot() to w.01
plot(summary(w.01), 
     breaks=ax)
```


# ===================== Part III. Outcome Analysis ==================== #

## 1.  Matched Pairs 1: age sex urban

```{r}
# Anti-N
#matched_dat01 <- match.data(match_03)
matched_dat01 <- match.data(match_01)
lmm.01.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=matched_dat01, family = binomial(link = "logit"))
summary(lmm.01.N)

# Anti_S
lmm.01.S<-lm(SPIKE_ANTIBODY~SER_ADM_COV,
    data=matched_dat01, weights = weights)
summary(lmm.01.S)

#Test the coefficient using cluster robust standard error
coeftest(lmm.01.S, vcov. = vcovCL, cluster = ~subclass)
#Calculate the confidence intervals based on cluster robust standard error
coefci(lmm.01.S, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

## 2.  Matched Pairs 2: added edu race healthcare

```{r}
# Anti-N
matched_dat02 <- match.data(match_02)
lmm.02.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=matched_dat02, family = binomial(link = "logit"))
summary(lmm.02.N)

# Anti_S
lmm.02.S<-lm(SPIKE_ANTIBODY~SER_ADM_COV,
    data=matched_dat02, weights = weights)
summary(lmm.02.S)

#Test the coefficient using cluster robust standard error
coeftest(lmm.02.S, vcov. = vcovCL, cluster = ~subclass)
#Calculate the confidence intervals based on cluster robust standard error
coefci(lmm.02.S, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

## 3a. Matched Pairs 6a: The logistic regression model applied in PSM is the best-fit model, subclass matching

```{r}
# Use the result from subclass matching method since it has better balance 
matched_dat06a <- match.data(match_06.a)

# OR of anti-N positive
lmm.06a.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=matched_dat06a, family = binomial(link = "logit"),
    weights = weights)
summary(lmm.06a.N)

lmm.06a.N %>%
  tbl_regression(exponentiate = T)

# OR of anti-S positive
lmm.06a.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
    data=matched_dat06a, family = binomial(link = "logit"),
    weights = weights)
lmm.06a.S %>%
  tbl_regression(exponentiate = T)
```

## 3.  Matched Pairs 6: The logistic regression model applied in PSM is the best-fit model, using nearest matching methods

```{r}
# Use the result from subclass matching method since it has better balance 
matched_dat06 <- match.data(match_06)

# OR of anti-N positive
lmm.06.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=matched_dat06, family = binomial(link = "logit"),
    weights = weights)
summary(lmm.06.N)

lmm.06.N %>%
  tbl_regression(exponentiate = T)

# OR of anti-S positive
lmm.06.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
    data=matched_dat06, family = binomial(link = "logit"),
    weights = weights)
lmm.06.S %>%
  tbl_regression(exponentiate = T)
```

#### Additional Analysis using match_09, excluding 40% cases
```{r}
# Used 60% cases, m9
matched_dat09 <- match.data(match_09)

# OR of anti-N positive
lmm.09.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=matched_dat09, family = binomial(link = "logit"),
    weights = weights)
summary(lmm.09.N)

lmm.09.N %>%
  tbl_regression(exponentiate = T)

# OR of anti-S positive
lmm.09.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
    data=matched_dat09, family = binomial(link = "logit"),
    weights = weights)
lmm.09.S %>%
  tbl_regression(exponentiate = T)
```

## 4. Analysis using unmatched data
```{r}
# Unmatched Analysis

# OR of anti-N positive
lmm.00.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
    data=CLSA_com50, family = binomial(link = "logit"))
lmm.00.N %>%
  tbl_regression(exponentiate = T)

# OR of anti-S positive
lmm.00.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
    data=CLSA_com50, family = binomial(link = "logit"))
lmm.00.S %>%
  tbl_regression(exponentiate = T)
```

Comparison of Quantitative Anti-S assay results, using match_06.a data

```{r}
# Anti-S Quantitative, using linear reg model, log-10 transformed
CLSA_com50$SPIKE_ANTIBODY_log<-log10(CLSA_com50$SPIKE_ANTIBODY)
lmm.06a.SQ <- lm(SPIKE_ANTIBODY_log~SER_ADM_COV,
                data=matched_dat06a[matched_dat06a$SER_SPIKE_COV==1,], weights = weights)
summary(lmm.06a.SQ)

# weighted t-test?

# Test the coefficient using cluster robust standard error
coeftest(lmm.06a.SQ, vcov. = vcovCL, cluster = ~subclass)

# Calculate the confidence intervals based on cluster robust standard error
coefci(lmm.06a.SQ, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

Notes: VBS is 0.84 units higher (95% CI: 0.77-0.91) than DBS, in log10 scale of quantitative Anti-S results

#### Weighted Data - Anti-N&S
```{r}
lmm.06.N<-glm(SER_NUCLEOCAPSID_COV~SER_ADM_COV,
           data=CLSA_com50.c6, family = binomial(link = "logit"),
           weights = w.weights)
# ummary(psw.06.N)

lmm.06.N %>%
  gtsummary::tbl_regression(exponentiate = T)

# OR of anti-S positive
lmm.06.S<-glm(SER_SPIKE_COV~SER_ADM_COV,
              data=CLSA_com50.c6, family = binomial(link = "logit"),
              weights = w.weights)
lmm.06.S %>%
  gtsummary::tbl_regression(exponentiate = T)
```


## ======== Part.IV Making Plots for outcomes (Anti-N & Anti-S) =============

This time we use **matched** data

## 1. plots for Anti-N (matched_01):
```{r}
p01.N.neg<-ggplot(matched_dat01[matched_dat01$SER_NUCLEOCAPSID_COV==0,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Negative") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data") +
  geom_violin(trim=F)

p01.N.pos<-ggplot(matched_dat01[matched_dat01$SER_NUCLEOCAPSID_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data") +
  geom_violin(trim=F)

p01.N.neg + geom_boxplot(width=0.05, color='red')
p01.N.pos + geom_boxplot(width=0.05, color='red')

# Plot not readable for positive results, trim the upper at 5
p01.N.pos5<-ggplot(matched_dat01[matched_dat01$SER_NUCLEOCAPSID_COV==1 &
                                 matched_dat01$NUCLEOCAPSID_ANTIBODY<5,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data, trimmed at 5") +
  geom_violin(trim=F)

p01.N.pos5+ stat_summary(fun.data="mean_sdl", mult=1, 
                 geom="crossbar", width=0.05, color='red' ) # plus mean & std, biased in this case

p01.N.pos5+ geom_boxplot(width=0.05, color='red')
```

#### Plots for Anti-S (matched_01)

```{r}
p01.S.neg<-ggplot(matched_dat01[matched_dat01$SER_SPIKE_COV==0,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Negative") +
  labs(title = "Violin Plot for Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p01.S.pos<-ggplot(matched_dat01[matched_dat01$SER_SPIKE_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p01.S.neg + geom_boxplot(width=0.05, color='orange')
p01.S.pos + geom_boxplot(width=0.025, color='orange')

# Plot not readable for positive results, trim the upper at 5
p01.S.pos20<-ggplot(matched_dat01[matched_dat01$SER_SPIKE_COV==1 &
                                 matched_dat01$SPIKE_ANTIBODY<20,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-S Results, using matched data, trimmed at 20") +
  geom_violin(trim=F)

p01.S.pos20+ geom_boxplot(width=0.05, color='orange')
```

## 2. Plots for match_02 data

#### Anti-N
```{r}
p02.N.neg<-ggplot(matched_dat02[matched_dat02$SER_NUCLEOCAPSID_COV==0,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Negative") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data") +
  geom_violin(trim=F)

p02.N.pos<-ggplot(matched_dat02[matched_dat02$SER_NUCLEOCAPSID_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data") +
  geom_violin(trim=F)

p02.N.neg + geom_boxplot(width=0.05, color='red')
p02.N.pos + geom_boxplot(width=0.05, color='red')

# Plot not readable for positive results, trim the upper at 5
p02.N.pos5<-ggplot(matched_dat02[matched_dat02$SER_NUCLEOCAPSID_COV==1 &
                                 matched_dat02$NUCLEOCAPSID_ANTIBODY<5,]
       , aes(x=as.factor(SER_ADM_COV), y=NUCLEOCAPSID_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-N Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-N Results, using matched data, trimmed at 5") +
  geom_violin(trim=F)

p02.N.pos5+ geom_boxplot(width=0.05, color='red')
```

#### Plots for Anti-S (matched_02)
```{r}
p02.S.neg<-ggplot(matched_dat02[matched_dat02$SER_SPIKE_COV==0,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Negative") +
  labs(title = "Violin Plot for Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p02.S.pos<-ggplot(matched_dat02[matched_dat02$SER_SPIKE_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p02.S.neg + geom_boxplot(width=0.05, color='orange')
p02.S.pos + geom_boxplot(width=0.025, color='orange')

# Plot not readable for positive results, trim the upper at 20
p02.S.pos20<-ggplot(matched_dat02[matched_dat02$SER_SPIKE_COV==1 &
                                 matched_dat02$SPIKE_ANTIBODY<20,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-S Results, using matched data, trimmed at 20") +
  geom_violin(trim=F)

p02.S.pos20+ geom_boxplot(width=0.05, color='orange')
```

## 3. Plots for Anti-S (matched_06a)
```{r}
p06a.S.pos<-ggplot(matched_dat06a[matched_dat06a$SER_SPIKE_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p06a.S.pos + geom_boxplot(width=0.025, color='orange')

# Plot not readable for positive results, trim the upper at 20
p06a.S.pos20<-ggplot(matched_dat06a[matched_dat06a$SER_SPIKE_COV==1 &
                                    matched_dat06a$SPIKE_ANTIBODY<20,]
       , aes(x=as.factor(SER_ADM_COV), y=SPIKE_ANTIBODY)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Numeric Anti-S Results, using matched data, trimmed at 20") +
  geom_violin(trim=F)

p06a.S.pos20+ geom_boxplot(width=0.05, color='orange')
```

#### Log-10 transform, then do the plot again
```{r}
## log-10 transformation
p06a.S.pos_lg10<-ggplot(matched_dat06a[matched_dat06a$SER_SPIKE_COV==1,]
       , aes(x=as.factor(SER_ADM_COV), y=log(SPIKE_ANTIBODY),base=10)) + 
  labs(x="0=DBS, 1=VBS", y="Anti-S Ab Assay - Positive") +
  labs(title = "Violin Plot for Log10-Transformed Quant Anti-S Results, using matched data") +
  geom_violin(trim=F)

p06a.S.pos_lg10 + geom_boxplot(width=0.025, color='orange')
```

Calculate five numbers for the plot above
```{r}
# DBS
summary(matched_dat02$SPIKE_ANTIBODY[matched_dat02$SER_ADM_COV==0 &
                                     matched_dat02$SER_SPIKE_COV==1])
# VBS
summary(matched_dat02$SPIKE_ANTIBODY[matched_dat02$SER_ADM_COV==1 &
                                     matched_dat02$SER_SPIKE_COV==1])
```

#### eCDF function testing Anti-S
```{r}
ecdf_S_DBS<-matched_dat06 %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==0,] %>%
  .$SPIKE_ANTIBODY

# Plot seperately
plot(ecdf(ecdf_S_DBS), main='eCDF of Quant Anti-S Assay Results 
                      (log10 transformed) among DBS',
     xlab = 'Quant Anti-S Assay Results-1og10 Transformed')
  
ecdf_S_VBS<-matched_dat06 %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==1,] %>%
  .$SPIKE_ANTIBODY

plot(ecdf(ecdf_S_VBS), main='eCDF of Quant Anti-S Assay Results 
                      (log10 transformed) among VBS',
     xlab = "Quant Anti-S Assay Results-log10 Transformed")
```

#### Comparing the diff using K.S Test
```{r}
# Kolmogorov-Smirnov Test (KS Test)
# Needs package from {dgof}
png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.1a eCDF Anti-S.png", 
    width=1600, height=1200, res=300)
plot(stats::ecdf(ecdf_S_DBS),
     xlim = c(0.4,2500),
     log='x',
     xaxt = 'n',
     col = "blue",
     main='eCDF of Quant Anti-S Assay Results',
     xlab = 'Quant Anti-S Assay Results')
plot(stats::ecdf(ecdf_S_VBS),
     add = TRUE,
     lwd=2,
     lty = "dashed",
     col = "red")
axis(side=1, at=c(-0.4, 0, 1, 10, 100, 1000))
legend("bottomright", legend = c("DBS", "VBS"),
       lwd = 3, col = c("blue", "red"))
dev.off()
 
# performing the K-S
# Test on x and x2
ks.test(ecdf_S_DBS, ecdf_S_VBS, alternative = "two.sided")
```

The ecdf plot with Anti-N: in this part we probably need to do it seperately for Anti-N negative and Anti-N positive

```{r}
# Create the vectors for plotting, from subclass-matching weighted data

## N-negative
N_DBS_neg<-matched_dat06a %>%
  .[.$SER_NUCLEOCAPSID_COV==0 & .$SER_ADM_COV==0,] %>%
  .$NUCLEOCAPSID_ANTIBODY
N_VBS_neg<-matched_dat06a %>%
  .[.$SER_NUCLEOCAPSID_COV==0 & .$SER_ADM_COV==1,] %>%
  .$NUCLEOCAPSID_ANTIBODY

## N-positive
N_DBS_pos<-matched_dat06a %>%
  .[.$SER_NUCLEOCAPSID_COV==1 & .$SER_ADM_COV==0,] %>%
  .$NUCLEOCAPSID_ANTIBODY
N_VBS_pos<-matched_dat06a %>%
  .[.$SER_NUCLEOCAPSID_COV==1 & .$SER_ADM_COV==1,] %>%
  .$NUCLEOCAPSID_ANTIBODY
```

```{r}
# Create the ecdf plot:

## Anti-N neg
png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.1b eCDF Anti-N_neg.png", 
    width=1800, height=1200, res=300)
plot(ecdf(N_DBS_neg),
     xlim = range(N_DBS_neg, N_VBS_neg),
     col = "green",
     main='eCDF of Quant Anti-N Assay Results - Negative',
     xlab = 'Quant Anti-N Assay Results')
plot(ecdf(N_VBS_neg),
     add = TRUE,
     lwd=2,
     lty = "dashed",
     col = "orange")
legend("bottomright", legend = c("DBS", "VBS"),
       lwd = 3, col = c("green", "orange"))
dev.off()

## Anti-N pos: using log10 scale

png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.1b eCDF Anti-N_pos.png", 
    width=1800, height=1200, res=300)
plot(ecdf(N_DBS_pos),
     xlim = range(0.1, 100),
     log='x',
     xaxt = 'n',
     col = "green",
     main='eCDF of Quant Anti-N Assay Results - Positive',
     xlab = 'Quant Anti-N Assay Results')
plot(ecdf(N_VBS_pos),
     add = TRUE,
     lwd=2,
     lty = "dashed",
     col = "orange")
axis(side=1, at=c(0.1, 1, 10, 100))
legend("bottomright", legend = c("DBS", "VBS"),
       lwd = 3, col = c("green", "orange"))
dev.off()


# Test the diff
ks.test(N_DBS_neg, N_VBS_neg, alternative = "two.sided")
ks.test(N_DBS_pos, N_VBS_pos, alternative = "two.sided")
```

#### Weighted ecdf, using IPTW weights

```{r}
# We used the ewcdf() from {spatstat} package
table(CLSA_com50.c6$SER_ADM_COV, CLSA_com50.c6$SER_SPIKE_COV)

# DBS with Spike+, N=1816
wecdf_S_DBS<-CLSA_com50.c6 %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==0,] %>%
  .$SPIKE_ANTIBODY

# VBS with Spike+, N=1572
wecdf_S_VBS<-CLSA_com50.c6 %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==1,] %>%
  .$SPIKE_ANTIBODY
```

#####  Make and print the plot
```{r}
png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.1c Weighted eCDF Anti-S.png", 
    width=1600, height=1200, res=300)
plot(ewcdf(wecdf_S_DBS,
           weights=CLSA_com50.c6$w.weights[CLSA_com50.c6$SER_ADM_COV==0 &
                                          CLSA_com50.c6$SER_SPIKE_COV==1]),
     xlim = c(0.4,2500),
     log='x',
     xaxt = 'n',
     col = "blue",
     main='Weighted eCDF of Quant Anti-S Assay Results',
     xlab = 'Quant Anti-S Assay Results')
plot(ewcdf(wecdf_S_VBS,
          weights=CLSA_com50.c6$w.weights[CLSA_com50.c6$SER_ADM_COV==1 &
                                          CLSA_com50.c6$SER_SPIKE_COV==1]),
     add = TRUE,
     lwd=2,
     col = "red")
axis(side=1, at=c(-0.4, 0, 1, 10, 100, 1000))
legend("bottomright", legend = c("DBS", "VBS"),
       lwd = 3, col = c("blue", "red"))
dev.off()
```

##### Addtional Codes: Why the unweighted and weighted eCDF looks exactly the same?
```{r}
# The codes below use a very small subset -- first 10 obs from the DBS group. Now the difference is visible, proving that all eCDF functions we tested so far are working well, the difference between weighted and unweighted eCDF is too small to be visible.

wecdf_S_DBS<-wecdf_S_DBS[1:10] # a 10-obs subset for DBS

plot(ewcdf(wecdf_S_DBS),
     xlim = c(0.4,2500),
     log='x',
     xaxt = 'n',
     col = "blue",
     main='Weighted eCDF of Quant Anti-S Assay Results',
     xlab = 'Quant Anti-S Assay Results')
plot(ewcdf(wecdf_S_DBS,
          weights=CLSA_com50.c6$w.weights[CLSA_com50.c6$SER_ADM_COV==0 &
                                          CLSA_com50.c6$SER_SPIKE_COV==1][1:10]),
     add = TRUE,
     lwd=2,
     col = "green")
axis(side=1, at=c(-0.4, 0, 1, 10, 100, 1000))
legend("bottomright", legend = c("DBS: 1st 10 Obs, unweighted", "DBS: 1st 10 Obs, weighted"),
       lwd = 3, col = c("blue", "green"))
```

weighted ecdf, using stat_ecdf in {ggplot2} package
```{r}
source("../2_scripts/stat_ecdf_weighted.R")

# unweighted version
ggplot(CLSA_com50.c6[CLSA_com50.c6$SER_SPIKE_COV==1,], 
       aes(x=SPIKE_ANTIBODY, color=as.factor(SER_ADM_COV))) +
       stat_ecdf(geom = "step") +
       coord_trans(x="log10") +
       ggtitle("eCDF plot unweighted")

# weighted version
ggplot(CLSA_com50.c6[CLSA_com50.c6$SER_SPIKE_COV==1,], 
       aes(x=SPIKE_ANTIBODY, color=as.factor(SER_ADM_COV)),
           weight = w.weights) +
       stat_ecdf(geom = "step") +
       coord_trans(x="log10")+
       theme_bw() + 
       ggtitle("eCDF plot weighted")

```


Another weighted ecdf, using weights from subclass matching
```{r}
S_DBS_pos<-matched_dat06a %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==0,] %>%
  .$SPIKE_ANTIBODY

S_VBS_pos<-matched_dat06a %>%
  .[.$SER_SPIKE_COV==1 & .$SER_ADM_COV==1,] %>%
  .$SPIKE_ANTIBODY

plot(ewcdf(S_DBS_pos, 
           weights=matched_dat06a$weights[matched_dat06a$SER_ADM_COV==0 &
                                          matched_dat06a$SER_SPIKE_COV==1]),
     xlim = c(0.4,2500),
     log='x',
     xaxt = 'n',
     col = "blue",
     main='Weighted eCDF of Quant Anti-S Assay Results',
     xlab = "add Xlab here")
plot(ewcdf(S_VBS_pos,
           weights=matched_dat06a$weights[matched_dat06a$SER_ADM_COV==0 &
                                          matched_dat06a$SER_SPIKE_COV==1]),
     add = TRUE,
     lwd=2,
     lty = "dashed",
     col = "red")
axis(side=1, at=c(-0.4, 0, 1, 10, 100, 1000))
legend("bottomright", legend = c("DBS", "VBS"),
       lwd = 3, col = c("blue", "red"))
```

As it indicated clear above, when sample size is small (~10) we could observe the difference btw unweighted eCDF and weighted eCDF. However, when the sample size is large (~1000) the difference between two figure is not visible to human readers

## ========================= Part. V OR Plot ===============================

#### Model.06
```{r}
CLSA_com50$dist_min_km<-CLSA_com50$dist_min/1000
CLSA_com50$age10<-CLSA_com50$AGE_NMBR_COVID/10
label(CLSA_com50$age10)="Age in 10-year Scale"
# The regression model: Best-fit Model
lm06p <- glm(SER_ADM_COV ~ age10 + 
            URBAN_RURAL_COVID +
            relevel(SER_ETHN_WH_COV, ref='1=WH')  +
            SER_EDU_COV +
            DEP_CESD10_COVX +
            dist_min_km +
            time_vac15 +
            relevel(PROV_5, ref='5 = BC') + outbreak, 
            data=CLSA_com50,
            family = binomial(link='logit'))
summary(lm06p)

tbl_regression(lm06p, exponentiate = T)
```

#### Model.06u
```{r}
# Same model as model 06, but few variable are recoded to make the OR plot more visual-friendly.

lm06.u <- glm(SER_ADM_COV~age10 + 
            SEX_CLSA +
            urban_rural +
            relevel(SER_ETHN_WH_COV, ref = '1=WH')  +
            SER_EDU_COV +
            DEP_CESD10_COVX +
            dist_min_25km +
            time_vac15 + avginc10_15d +
            PROV_5, 
            data=CLSA_com50,
            family = binomial(link='logit'))
gtsummary::tbl_regression(lm06.u, exponentiate = T)

# Additional Modeling with int terms
lm06.ui <- glm(SER_ADM_COV~age10 + 
            SEX_CLSA +
            urban_rural +
            relevel(SER_ETHN_WH_COV, ref = '1=WH')  +
            SER_EDU_COV +
            DEP_CESD10_COVX +
            dist_min_25km +
            time_vac15 + avginc10_15d +
            relevel(PROV_5, ref = '5 = BC') + 
            relevel(PROV_5, ref = '5 = BC')*avginc10_15d, 
            data=CLSA_com50,
            family = binomial(link='logit'))
gtsummary::tbl_regression(lm06.ui, exponentiate = T)

summary(lm06.u)  # AIC=8016.8
summary(lm06.ui) # AIC=7881.3

lmtest::lrtest(lm06.u, lm06.ui)
# We found significant diff between the non-int model and the model with int btw prov and incidence. The inc itself is prov-specific, so it make sense the AIC decreases as we add interaction terms.
```



#### Build Simple OR for each variable

```{r}
# Build a function for simple regression and OR
simple_reg_OR<-function(v){
 lm_temp<-glm(SER_ADM_COV~v, data=CLSA_com50,
             family = binomial(link='logit'))
 print(summary(lm_temp))
 gtsummary::tbl_regression(lm_temp, exponentiate = T)
}

simple_reg_OR.w<-function(v){
 lm_temp<-glm(SER_ADM_COV~v, data=CLSA_com50.c6,
             family = binomial(link='logit'), weights = CLSA_com50.c6$w.weights)
 print(summary(lm_temp))
 gtsummary::tbl_regression(lm_temp, exponentiate = T)
}

# test using age (10-year scale)
simple_reg_OR(CLSA_com50$age10) # Looks good
simple_reg_OR.w(CLSA_com50.c6$age10) # Looks good
```

```{r}
# Add other variables
simple_reg_OR(CLSA_com50$SEX_CLSA)                            # Sex

simple_reg_OR(CLSA_com50$urban_rural)                         # Rural/Urban, 3cate

simple_reg_OR(relevel(CLSA_com50$SER_ETHN_WH_COV, ref='1=WH'))# WH/Non-WH

simple_reg_OR(CLSA_com50$SER_EDU_COV)                         # Education

simple_reg_OR(CLSA_com50$DEP_CESD10_COVX)                     # Dep Scale

simple_reg_OR(CLSA_com50$dist_min_25km)                       # Travel Dist

simple_reg_OR(CLSA_com50$time_vac15)                          # Vax>15 Days?

simple_reg_OR(relevel(CLSA_com50$PROV_5, ref='5 = BC'))       # Prov, ref=BC

simple_reg_OR(CLSA_com50$avginc10_15d)                        # Outbreak Peak*

# *Outbreak Peak* is defined by: >50 confirmed cases/1 million pop in Canada. Due to the delayed effect of infection to elevated Ab level, we left-shift it by 15 days. So it's "outbreak peak 15 days ago".
```
#### Add bivariate analysis using weighted data
```{r}
simple_reg_OR.w(CLSA_com50.c6$SEX_CLSA)                            # Sex

simple_reg_OR.w(CLSA_com50.c6$urban_rural)                         # Rural/Urban, 3cate

simple_reg_OR.w(relevel(CLSA_com50.c6$SER_ETHN_WH_COV, ref='1=WH'))# WH/Non-WH

simple_reg_OR.w(CLSA_com50.c6$SER_EDU_COV)                         # Education

simple_reg_OR.w(CLSA_com50.c6$DEP_CESD10_COVX)                     # Dep Scale

simple_reg_OR.w(CLSA_com50.c6$dist_min_25km)                       # Travel Dist

simple_reg_OR.w(CLSA_com50.c6$time_vac15)                          # Vax>15 Days?

simple_reg_OR.w(relevel(CLSA_com50.c6$PROV_5, ref='5 = BC'))       # Prov, ref=BC

simple_reg_OR.w(CLSA_com50.c6$avginc10_15d)                        # Outbreak Peak*

```



#### Import the OR table

```{r}
# This OR table is created outside of R manually, by filling the ORs from model.06p and those from simple logistic regression models above.
library(readxl)
OR_import <- read_excel("~/dbs-vs-venous-antibodies/3_intermediate/OR_import.xlsx",
                        sheet = "Reg")
OR_import$Adj<-as.factor(OR_import$Adj)

# Edit the data, add sig indicator
OR_import$alpha <- rep(1, length(OR_import$group))
OR_import$alpha[(OR_import$lower <1 & OR_import$higher <1) |
            (OR_import$lower >1 & OR_import$higher >1)]<-0
OR_import$alpha<-as.factor(OR_import$alpha)
levels(OR_import$alpha)=c("Significant","Insignificant")


g01<-ggplot(OR_import, aes(x = OR, y = group)) + 
    geom_vline(aes(xintercept = 1), size = .75, linetype = "dashed",color='red')+
    geom_errorbarh(aes(xmax = higher, xmin = lower, color=Adj, linetype=alpha),
                       position = position_dodge(width = 1.0),
                       linewidth = .5, height = .5) +
    geom_point(size = 2, aes(colour=Adj,  shape=alpha),
               position = position_dodge(width = 1.0))+
    scale_shape_manual(values=c(16, 1))+
    theme_bw()+
    theme(plot.background = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          legend.title = element_blank(),
          axis.title.y = element_blank()
          ) +
  labs(x = "Odds ratio (>1 indicates propensity for in-person venous sample)")

# Plot is good, but needs to add shadows for aesthetic purposes 
```

#### Applying GG forest

```{r}
# Load this package first
library(ggforestplot) #From Github, not in pak tab but you can load it

# Add shadows and save the plot
png(file="~/dbs-vs-venous-antibodies/3_intermediate/Fig.3 OR Plot.png", 
    width=2400, height=1440, res=300)
g01+geom_stripes(odd = "#33333333", even = "#00000000")+
   scale_color_brewer(palette="Set1") 
dev.off()
```

## Save com50 data

```{r}
save(CLSA_com50, file = '~/dbs-vs-venous-antibodies/1_data/private/CLSA_com50.RData')
```
